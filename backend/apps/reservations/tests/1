import datetime
from unittest.mock import patch, MagicMock

from django.urls import reverse
from rest_framework import status
from rest_framework.test import APITestCase

from apps.accounts.models import User, CustomerProfile, HotelOwnerProfile
from apps.hotel.models import Hotel, Room
from apps.reservations.models import Reservation

# Assuming a UserFactory exists from the other app
from apps.accounts.tests.factories import UserFactory


class ReservationAPITests(APITestCase):
    def setUp(self):
        """Set up the necessary objects for the tests."""
        # Create users
        self.owner_user = UserFactory(user_type='hotel_owner')
        self.customer_user = UserFactory(user_type='customer')

        # Create profiles
        HotelOwnerProfile.objects.create(user=self.owner_user)
        self.customer_profile = CustomerProfile.objects.create(user=self.customer_user)

        # Create hotel and room
        self.hotel = Hotel.objects.create(owner=self.owner_user, name="Test Hotel", city="Test City")
        self.room = Room.objects.create(hotel=self.hotel, title="Deluxe Room", price_per_night=150.00)

        # URL for creating a reservation
        self.create_url = reverse('reservations_v1:room-reserve', kwargs={'room_id': self.room.id})

        # Authenticate the client as the customer
        self.client.force_authenticate(user=self.customer_user)

    def test_create_reservation_success(self):
        """
        Ensure a reservation can be created successfully for an available room.
        """
        data = {
            "checking_date": "2025-11-01",
            "checkout_date": "2025-11-03",
            "room": self.room.id, # The serializer expects the room id in the body
        }
        response = self.client.post(self.create_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertTrue(Reservation.objects.filter(room=self.room, user=self.customer_profile).exists())

    def test_create_reservation_fails_with_date_conflict(self):
        """
        Ensure the API returns a validation error if the room is already booked.
        This tests the initial check in the serializer.
        """
        # Create a pre-existing reservation
        Reservation.objects.create(
            user=self.customer_profile,
            room=self.room,
            checking_date=datetime.datetime(2025, 11, 1, tzinfo=datetime.timezone.utc),
            checkout_date=datetime.datetime(2025, 11, 5, tzinfo=datetime.timezone.utc),
            total_price=600
        )

        data = {
            "checking_date": "2025-11-02",  # This range overlaps with the one above
            "checkout_date": "2025-11-04",
            "room": self.room.id,
        }
        response = self.client.post(self.create_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        # The error message comes from our custom validation
        self.assertIn("not available", str(response.data))

    @patch('core.redis_client.redis_client.lock')
    def test_create_reservation_fails_if_lock_cannot_be_acquired(self, mock_redis_lock):
        """
        Ensure the API returns a 'service_unavailable' error if the Redis lock cannot be acquired.
        """
        # Configure the mock lock object to simulate a failure to acquire
        mock_lock_instance = MagicMock()
        mock_lock_instance.acquire.return_value = False
        mock_redis_lock.return_value = mock_lock_instance

        data = {
            "checking_date": "2025-12-10",
            "checkout_date": "2025-12-12",
            "room": self.room.id,
        }
        response = self.client.post(self.create_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("currently being booked", str(response.data))

    @patch('apps.reservations.models.Reservation.objects.is_room_available')
    @patch('core.redis_client.redis_client.lock')
    def test_create_reservation_fails_if_room_booked_during_lock(self, mock_redis_lock, mock_is_available):
        """
        Ensure the API returns a 'conflict' error if the room becomes unavailable
        after the lock is acquired, simulating a classic race condition.
        """
        # Configure the lock to be acquired successfully
        mock_lock_instance = MagicMock()
        mock_lock_instance.acquire.return_value = True
        mock_redis_lock.return_value = mock_lock_instance

        # Simulate the race condition:
        # 1. The first check (in the serializer) passes.
        # 2. The second check (inside the locked view) fails.
        mock_is_available.side_effect = [True, False]

        data = {
            "checking_date": "2025-12-20",
            "checkout_date": "2025-12-22",
            "room": self.room.id,
        }
        response = self.client.post(self.create_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("has just been booked", str(response.data))
        # Ensure we checked availability twice
        self.assertEqual(mock_is_available.call_count, 2)


